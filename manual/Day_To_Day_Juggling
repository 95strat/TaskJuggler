== Day To Day Juggling ==


=== Tracking the Project ===

Once the initial plan has been made and the project has started, TaskJuggler
can be turned from a planning tool into a tracking tool. You don't have to
change a lot to do this. After all, as the initial plan is almost always just a
first guess, you need to continue planning your project as new details become
evident. So what you really want is a way to gradually freeze the plan as work
has been completed, while still having full flexibility with all future work.

While it is generally accepted to invest some amount of time in project
planning, it is very common that once the project has been started, project
managers tend to avoid a proper tracking of the project. Our bet is that the
vast majority of project plans are only made to get management or investor
approval. After the approval phase, many project managers only work with their
project plan again when the project is running really late. On the other hand
there are projects that are done using strict project management techniques
that require detailed status tracking. Both extremes probably have their fans
and TaskJuggler offers good support for both extremes as well as various
techniques in between.

=== Recording Progress ===

As mentioned previously, your initial project plan is only a first estimate of
how the project will progress. During the course of the project you will have
to make changes to the plan as new information needs to be taken into account
and you probably want to track the progress of the project in a formalized
form. TaskJuggler will support you during this phase of the project as well,
but it needs your help. You have to provide the additional information in the
project file. In return you get current status reports and an updated project
plan based on the current status of the project.

==== Using completion values ====

The most simple form of capturing the current status of the project is to use
the complete attribute.

 task impl "Implementation" {
   depends !spec
   effort 4w
   allocate dev1, dev2
   complete 50
 }

This tells TaskJuggler that 50% of the task's effort has been completed by the
[[now|current date]]. Tasks that have no completion specification will
be assumed to be on track. TaskJuggler calculates the expected
completion degree based on the current date. Completion specifications
only need to be supplied for tasks that are either ahead of schedule
or behind schedule. Please be aware that the completion degree does
not affect the scheduling and resource allocation. It is only for
reporting purposes. It also does not tell TaskJuggler which resource
actually worked on the tasks, nor does it update the total or
remaining effort.

==== Using bookings ====

When TaskJuggler schedules your plan, it can tell you who should work
when on what. Now, that's the plan. But reality might be different.
To tell TaskJuggler what really happened, you can use
[[booking.task|booking statements]]. When the past is exactly
described by providing booking statements, you can enable
[[projection|projection mode]].

Entering all the bookings for each resource and task may sound like a
daunting task at first. If you do it manually, it certainly is.
Fortunately, TaskJuggler can generate them for you by using
[[export|export reports]]. Before we discuss this in more detail, we
need to make sure that the plan is up-to-date.

=== Tracking status and actuals ===

Creating a good project plan is one thing. Executing it is a whole
new story. Usually, the first plan is never fully correct and the
only way to make sure that you are making progress according to plan
is to regularly get status updates from all resources.

Status updates should be provided by all project contributors on a
regular basis, usually once a week. These updates should tell project
managers who really worked how much on what tasks and how much work
the contributors believe is really left now. There are two categories
of tasks in a project that need to be treated slightly differently.

A task can either be effort based or duration based. In the former
case, the contributors must tell how much effort is left. For
duration based task, this doesn't make much sense. For these task,
the expected end date should be reported.

In addition to those numbers, managers in the reporting chain usually
want to have a textual status that describes what happened and what
kind of issues were encountered. Usually, these textual status
reports are combined with alert levels like green, yellow and red.
Green means everything is progressing according to plan, yellow means
there is some schedule risk and red means serious trouble. Usually
first line managers like to get all the details while people further
up in the reporting chain only like to see summaries varying level of
details.

All of this creates additional overhead but is usually inevitable to
ensure that you complete the project within time and budget. As a
comprehensive project management solution, TaskJuggler provides full
support for all those tracking and reporting steps. It comes with a
powerful email and web based communication system that simplifies the
tracking process for individual contributors as well as managers.

==== The reporting and tracking cycle ====

In this description, we assume that you are using a weekly reporting
cycle. TaskJuggler does support arbitrary cycles, but we highly
recommend the described weekly cycle.

# '''Time sheets''': Every project contributor needs to fill out a
[[timesheet|time sheet]] once a week. To simplify this task as much
as possible, a template will be send out by email. The template
already lists all tasks that were planned for this week to work on
with the respective effort values and end dates. It also provides
sections for textual status reports. The contributor needs to review
and complete the time sheet and has to send it back via email.
TaskJuggler validates the submission and returns an email with either
an error message or a nicely formatted version of the time sheet.

# All time sheets must be submitted by a certain deadline, e. g.
midnight on Sunday. TaskJuggler will then compile a summary report
and sent it out to a list of interested parties. It will also detect
missing time sheets and will send out a reminder to those
contributors that have not submitted their report.

# On Monday the project managers need to review the time sheets and
update the plan accordingly. TaskJuggler can compile a list changes
compared to the plan. This makes it easy to update the plan according
to the actual progress that was made. The close the actuals match the
plan the less work this is. The project managers now generate
bookings for the last week and add them to the database with previous
bookings. Doing so, will prevent changes to the plan to affect the
past. Only the future will be modified.

# Once the plan has been updated, managers will receive their status
sheet templates per email. Each manager will get the information for
the tasks that they are [[responsible]] for. To consolidate the
information for the next manager in the reporting chain they can
moderate the reports in three ways. Consolidated manager reports are
called dashboard reports.

## A status report for a task can be removed from the dashboard.

## A status report for a task can be corrected or updated.

## All reports for sub tasks of a task can be summarized by creating
a new status for that task. This will remove all reports for sub
tasks of that particular tasks from the dashboard.

# Managers than need to send back the edited status report via email.
Like with time sheets, TaskJuggler will check them and return either
an error message or a plain text version of the dashboard report of
the manager.

In addition to the plain text versions of the time sheet summaries
and the dashboards, TaskJuggler provides support for publishing them
as HTML pages from a web server.

=== Implementing the status tracking system ===

==== Prerequesites ====

The .tjp and .tji files of your project plan should be managed by a
revision control system. TaskJuggler does not require a particular
software, but for this manual we illustrate the implementation with
[http://subversion.apache.org Subversion]. It should be obvious how
to do this with other software though.

All communication of time sheets and status sheets is done via email.
TaskJuggler has built-in support for sending emails. To receive
emails and to feed them to the correct program, TaskJuggler needs
support from a mail transfer agent (MTA) and a mail processor. In
this documentation we describe the setup with
[http://www.postfix.org/ postfix] as MTA and
[http://www.procmail.org/ procmail] as mail processor. These are
standard parts of any Linux distribution and should be easy to setup.
It's certainly possible to use other MTAs and mail processors, but
this is not the scope of this manual.

Finally, you need a web server to publish your reports. This can
really be any web server. The generated reports are static HTML pages
that can simply be put into a directory that the web server is
serving.

For the email based communication you need to provide email addresses
for all project contributors. This is done in the project plan in the
resource definition. As there is no built-in attribute for email
addresses, you need to create one first using the [[extend]] attribute.

 extend resource {
   text Email "Email address"
 }

This attribute can now be used in the resource definitions to specify
email addresses for each resource

 resource joe "Joe Avergage" {
   Email "joe@your_company.com
 }

In this manual, we assume you have a dedicated Linux machine with a
local user called ''''taskjuggler''''. Your project files (*.tjp and
<nowiki>*</nowiki>.tji) is under Subversion control and the
taskjuggler user has a checked-out version in
''''/home/taskjuggler/projects/prj''''. You can use another user name,
another source code management system and even another operating
system like Windows or MacOS. This is all possible, but not the scope
of this manual.

==== The TaskJuggler Server ====

Depending on the size of your project the scheduling time can take
several minutes or more. Since all operations need to be done on the
data of a scheduled project, it makes sense to have this data readily
available. This is the job of the TaskJuggler server or daemon in
Linux lingo. The program is called ''''tj3d''''. When started, it
automatically disconnects from the terminal and runs in the
background. All interactions with the server are done via the TCP/IP
protocol. For security reasons, only connections from the same
machine (localhost) are accepted. To get access all clients must
provide an authentication key. A TaskJuggler server can serve any
number of projects. Once a project has been loaded successfully,
clients can retrieve the data in form of reports. Projects are
identified by their project ID. If a newly added project has the same
ID such as an already loaded project, the new project will replace
the old project once it was scheduled successfully. Before you start
the server, you need to provide a configuration file with some basic
settings.

All taskjuggler components can use the same TaskJuggler configuration
file. The format is a simple plain text format that follows the
[http://www.yaml.org/ YAML specification]. The file should be called
''''.taskjuglerrc'''' or ''''taskjuggler.rc''''. The settings are
structured by sections. Section names always start with an underscore.

 _global:
   authKey: topsecret
   _log:
     logLevel: 3
     outputLevel: 3

This file sets the authentication key for all TaskJuggler components.
You must replace ''topsecret'' with your own random character
sequence.

For the purpose of this documentation we assume you have a local user
called ''taskjuggler'' and your project data in
''''/home/taskjuggler/project/prj''''. Your TaskJuggler configuration
should then be put into
''''/home/taskjuggler/project/prj/.taskjugglerrc''''.

The log section controls the content of the log file. Since the
daemon does not have a terminal attached to it, all messages are
stored in a file called ''''tj3d.log''''. For debugging purposes, you
can use the ''''-d'''' option to prevent the daemon from
disconnecting from the terminal. In this case the ''''outputLevel''''
configuration option controls the amount of details to be printed out.

* 0: No output
* 1: Only fatal errors
* 2: Fatal and normal errors
* 3: Like 2, but additionally with information messages
* 4: Like 3, but additionally with debug messages

The configuration file will be searched in the current directory,
the current user's home directory or ''''/etc''''. You can also
explicitly tell the server where to find the configuration file with
the ''''-c'''' option. See

 tj3d --help

for details.

==== The TaskJuggler Client ====

To control the TaskJuggler server, you need to use the TaskJuggler
client. You can use the client to add or remove projects from the
server, inquire the status of loaded projects. It can also be used to
show the available reports for each project and to generate report or
check time or status sheets.

The client must provide the correct authentication key to the server.
You need to ensure that it can find the proper configuration file
with the authentication key.

 tj3client --help

will provide a full lust of supported commands. To load a project
simply type

 tj3client add yourproject.tjp

In case there were no errors

 tj3client status

should now list your project.

 tj3client list-reports <project_id>

shows a list of available reports for the project with the provided
ID. To generate a report, you can type

 tj3client report <project_id> <report_id>

==== The Time Sheet Template Sender ====

Each project contributor needs to fill out a time sheet each week. To
simplify the process each contributor will receive a template that
already contains a lot of the information they need to provide.

To send out the time sheets, the command ''''tj3ts_sender'''' must be
used. It will call ''''tj3client'''' with appropriate parameters. To
use it, you need to have a properly configured daemon running and the
appropriate project loaded. Then you need to add the configuration
data for ''''tj3ts_sender'''' to your TaskJuggler configuration file.
The time sheet related settings have their own top-level section:

 _global:
   smtpServer: smtp.your_company.com
   authKey: topsecret
   scmCommand: "svn add %f ; svn commit -m '%m' %f"
   projectId: prj
 _timesheets:
   senderEmail: 'TaskJuggler <timesheets@taskjuggler.your_company.com>'
   _sender:
     hideResource: '~isleaf()'
   _summary:
     sheetRecipients:
       - team@your_company.com
     digestRecipients:
       - managers@your_company.com

The ''''smtpServer'''' defines which host will handle your emails. Replace the
host name with your local SMTP server. The 'scmCommand' setting contains the
command to add and commit new and old files to the source code management
system. The command in this example works for Subversion.

The TaskJuggler server may serve multiple projects. With the
''''projectId'''' option you have to specify which project you would
like to work with. ''''senderEmail'''' is the email address the time
sheet infrastructure will use. Outgoing emails will have this address
as sender so that replies will come back to this email address. We'll
cover later how these are processed.

The hideResource option works similarly to the [[hideresource]]
attribute in the report definitions of the project plan. It allows
you to restrict the sending of time sheet templates to a subset of
your defined resources. In this example, we only want to send
templates to individual resources and not the teams you might have
defined.

By default the time sheets will cover the week from Monday morning
0:00 to Sunday night 24:00. When called without the ''''-e''''
option, ''''tj3ts_sender'''' will send out templates for the current
week.

To call the ''''tj3ts_sender'''' command you either need to be in the
''''/home/taskjuggler/projects/prj'''' directory or use the
''''-c'''' command line option to point it to the configuration file
to use. In the latter case you also need to call it with the
''''-d'''' option to change the output directory to your project
directory.

To test the command without sending out actual emails you can use the
''''--dryrun'''' option on the command line. To do its job,
''''tj3ts_sender'''' needs to generate a number of files and
directories. A copy of the generated templates will be stored in
''''TimeSheetTemplates/<date>/'''' under
''''<resource_id>-date.tji''''. ''''<date>'''' is replaced with the
end date of the reporting interval and ''''<resoruce_id>'''' is the ID
of the resource.

If you re-run the command existing templates will not be regenerated
nor will they be sent out again. You can use the ''''-f''''
command line option to force them to be generated and sent out again.

The ''''tj3ts_sender'''' command will also add the reporting interval
to a file called ''''TimeSheetTemplates/acceptable_invervals''''.
We'll cover this file later on when we deal with the time sheet
receiver.

==== The Time Sheet Receiver ====

To receive the filled-out time sheets and to process them
automatically you need to create a special user. TaskJuggler requires
a number of email addresses to be setup to receive emails. We
recommend to use the following setup. Create a special user called
''''taskjuggler'''' on a dedicated Linux machine. Then create the
following email aliases for this user.

 timesheets
 timesheet-request
 statussheets
 statussheet-request

Your MTA must be configured to use procmail for email delivery. See
the manual of your MTA for details on how to configure aliases and
for using procmail for delivery. If you have a resident MTA expert
you should ask him or her for support.

The next step is to configure procmail to forward the incoming emails
to the appropriate TaskJuggler components. Create a file called
''''.procmailrc'''' in the home directory of the taskjuggler user and
put in the following content:

For debugging and testing purposes, all incoming emails are archived
in a directory called ''''Mail''''. If there is no such directory in
the taskjuggler home directory, you need to create it now.

 PATH=$HOME/bin:/usr/bin:/bin:/usr/local/bin            
 MAILDIR=$HOME/Mail/                                    
 DEFAULT=$HOME/Mail/all                                 
 LOGFILE=$MAILDIR/procmail.log                          
 SHELL=/bin/sh                                          
 PROJECTDIR=/home/taskjuggler/projects/prj       
 LANG=en_US.UTF-8                                       
 LC_ALL=en_US.UTF-8                                     

 # Archive all incoming emails in a file called all 
 :0 c
 all 
 
 :0
 * ^Subject:.*Out of Office.*
 /dev/null                   
 
 :0
 * ^To:.*timesheets@taskjuggler\.your_company\.com
 {                                       
   :0 c:                                 
   timesheets                            
 
   :0 w: tj3ts_receiver.lock
   | tj3ts_receiver --silent -c $PROJECTDIR/.taskjugglerrc -d $PROJECTDIR
 
   :0
   failed_sheets
 }
 
 :0
 * ^To:.*timesheet-request@taskjuggler\.your_company\.com
 {
   ID=`formail -xSubject:`
 
   :0 c:
   timesheet-request
 
   :0 w: tj3ts_sender.lock
   | tj3ts_sender -r $ID -f --silent -c $PROJECTDIR/.taskjugglerrc -d $PROJECTDIR
 }
 
 :0
 * ^To:.*statussheets@taskjuggler\.your_company\.com
 {
   :0 c:
   statussheets
 
   :0 w: tj3ss_receiver.lock
   | tj3ss_receiver --silent -c $PROJECTDIR/.taskjugglerrc -d $PROJECTDIR
 
   :0
   failed_sheets
 }
 
 :0
 * ^To:.*statussheet-request@taskjuggler\.your_company\.com
 {
   ID=`formail -xSubject:`
 
   :0 c:
   statussheet-request
 
   :0 w: tj3ss_sender.lock
   | tj3ss_sender -r $ID -f --silent -c $PROJECTDIR/.taskjugglerrc -d $PROJECTDIR
 }
 
 # Forward a copy to project admins
 :0 c
 ! taskjuggler-admin@your_company.com
 
 # Since we have archived a copy we can discard all mails here.
 :0
 /dev/null

This procmail configuration will cause incoming emails that are
addressed to timesheets@taskjuggler.your_company.com to be forwarded
to the ''''tj3ts_receiver'''' program. Of course you need to replace
''your_comany.com'' with whatever domain you are using.

The received emails are then checked for syntactical and logical
errors. If such are found, an email is sent back with an appropriate
error message. The time sheet contains the resource ID of the
reporting resource. As soon as this has been detected, all email
communication will be sent to the email address in the project plan.
Only when the resource ID could not be identified, the sender of the
email will get the answer. This was implemented as a security measure
so other users cannot easily retrieve project related information
from other users.

Correct time sheets are archived in the ''''TimeSheets/<date>/''''
directory where ''''<date>'''' is the end date of the reporting
period. If the directory does not exist yet, it will be created. The
file will be called ''''<resource_id>-<date>.tji''''. If
a SCM command was specified, the file will be automatically put under
revision control. Subsequent submission of the same time sheet will
simply overwrite the earlier submissions. The file name will also be
added to a file called ''''all.tji'''' which consists of include
statements of all time sheet files in the directory. There also is an
automatically maintained file ''''all.tji'''' in the
''''TimeSheets'''' directory that includes all the ''''<date>/all.tji''''
files. To add all the submitted time sheets to your project plan,
simply include the top-level ''''all.tji''''.

''''tj3ts_receiver'''' will only accept time sheets for the time
periods listed in ''''TimeSheetTemplates/acceptable_intervals''''.
''''tj3ts_sender'''' will automatically enable the current period
when it sends out the templates. If you want to stop receiving time
sheet updates for a certain period, simply remove the period from the
''''acceptable_intervals'''' file.

==== Time Sheet Template Requests ====

Normally, the time sheets are sent out once a week automatically. In
case a project contributor leaves earlier for vacation or has lost
the template, they can request the template for the current week
again.

By sending an email to
''''timesheet-request@taskjuggler.your_company.com'''' and putting
their resource ID in the subject of the email, they will receive an
email with the time sheet template. The email will be sent to the
email address in the project plan, not the sender of the request
email.

==== Time Sheet Summaries ====

All time sheets should be successfully submitted by Sunday 24:00.
After this deadline, your can send out a summary of all submitted
time sheets. This summary will also contain a list of those project
contributors that have not submitted their time sheet. These
individuals will also get a reminder to submit their time sheets
immediately.

To send out the summary report, the program ''''tj3ts_summary'''' is
used. Before you can use it, you need to add a few settings to the
TaskJuggler configuration file.

 _global:
   smtpServer: smtp.your_company.com
   authKey: topsecret
   projectId: prj
 _timesheets:
   senderEmail: 'TaskJuggler <timesheets@taskjuggler.your_company.com>'
   _summary:
     sheetRecipients:
       - team@your_company.com
     digestRecipients:
       - managers@your_company.com

''''sheetRecipients'''' is a list of email addresses that should
receive a copy of the submitted time sheet. Each email address must
be put on a separate, properly indented line that starts with a dash
followed by a space. The emails will have the email of the original
time sheet author as sender address.

=== Recording Resource Usage ===

The initial project plan should be made by entering the minimum amount of
required information such as task dependencies and efforts. TaskJuggler will
then compute all the missing data based on this initial setup. This is your
project baseline. As the project progresses you can now track the work already
completed by recording the work that your resources have done. Let's assume you
had the following task in your original plan: 

 task impl "Implementation" {
   depends !spec
   effort 4w
   allocate dev1, dev2
 }

After the first week of work on this task the two resources have really been
able to complete half the job. You can capture this in your project plan using
the booking attribute. Bookings are resource specific, so you have to add the
booking to the resource definition, not the task definition.

 resource dev1 "Developer 1" {
   booking impl 2005-04-11 - 2005-04-16 { sloppy 2 }
 }
 
 resource dev2 "Developer 2" {
   booking impl 2005-04-11 - 2005-04-16 { sloppy 2 }
 }

The sloppy attribute defines the accuracy of your bookings. If it's missing or
0, the booking must only describe a continuous working period during working
hours. With higher values the interval may overlap with off-hour or vacation
time slots. See details on sloppy.

If you don't like to mix the resource definitions and their bookings, you can
specify the bookings with supplement statements. These supplement statements
can even reside in an other file. Some companies have created a web front-end
for their developers to report the completed work against the project plan. The
reports are stored in a database and include files for TaskJuggler are
generated from this database. This way the project manager gets a very current
status of the project and can compute the current project plan based on these
data without much effort. If you are interested in this you should have a look
at the download section of the TaskJuggler web site.

It is ok to specify bookings beyond the effort value found in the task
definition. In case you want to declare a task as done, even if the bookings do
not reach the specified effort or length, you can use the scheduled property.

 supplement task impl {
   actual:scheduled
 }

As a side note we would like to mention that the recording of the work time of
employees is regulated by labor law in certain countries. You might also
require approval from a Worker's Council before you can deploy time recording
tools.

In case your actual progress does not deviate a lot from your project plan, you
can generate the file with the booking statements automatically.

 export "DoneWork-Week15.tji" {
   hideresource 0
   start 2005-04-11
   end 2005-04-16
   taskattributes *
 }

This will generate a TaskJuggler include file that contains all bookings
according to the project plan for the specified interval. You can then use this
file as a baseline and modify it to reflect the real work that has happened
during the interval. After that you can include it into your project again.

 include "DoneWork-Week15.tji"

As this include file references the tasks and resources of your project you
should include it after all task and resource definitions.

To make TaskJuggler aware that you want to compute the end date based on the
bookings and the effort you need to enable the projection mode for the
scenario. This has to be done in the scenario definition in the project header.
If you don't have a scenario definition because you are only using the built-in
default scenario, you have to add a scenario definition.

 project prj "Project" "1.0" 2005-04-01 - 2005-05-01 {
   scenario plan "Plan" {
     # Compute when the task will be ready based on the already
     # done work and the current date.
     projection
   }
 }

TaskJuggler now assumes that for all tasks that have bookings, all work has
been specified with bookings up to the current date. It then calculates the end
date of the task based on the effort that is still left over. It also computes
the complete value based on the specified bookings. So if you specify bookings
for a task you should not specify a completion value as well. It will be
ignored and replaced by a value based on the specified bookings.

When you now schedule the project again, it will take these bookings into
account and generate a new project plan based on your current project status.
Each time you review your project status you should generate such an include
file for the period that you are reviewing. Then you sync the content with the
feedback that you get from your resources and add the file to the project plan.

